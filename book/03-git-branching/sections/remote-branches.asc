[[_remote_branches]]
=== 遠端分支

(((branches, remote)))(((references, remote)))
遠端參照是位於遠端版本庫上的參照，包括分支、標籤等等；
你可以使用 `git ls-remote [remote]` 明確地列出遠端參照完整的列表，或者使用 `git remote show [remote]` 取得更多遠端分支資訊；
然而，更好的方式是利用「遠端追蹤分支」。

遠端追蹤分支用來記錄遠端分支的狀態，
它們是無法移動的本地參照，但是會根據網路通訊的結果而自動移動；
它扮演著書籤的角色，用來提醒你上次與遠端通訊後那些遠端上的分支所在之處。

它們採用 `(遠端)/(分支)` 這樣的形式，
例如，你想看上次與 `origin` 版本庫通訊後，它的 `master` 分支指向哪一個提交，你應該查看 `origin/master` 分支；
如果你和同伴一起修正某個議題，而他先推送 `iss53` 分支到遠端版本庫；雖然在你的本地端可能也有一個 `iss53` 分支，但伺服器上的 `iss53` 分支會跟 `origin/iss53` 指向同一個提交。

可能有點令人困惑，所以讓我們直接舉例說明；
假設你的網路有一個 Git 伺服器位於 `git.ourcompany.com`，
你從這裡克隆時，Git 的 `clone` 命令會自動幫你把這個遠端版本庫命名為 `origin`，下載其中所有的資料，建立一個本地的 `origin/master` 並指向遠端的 `master` 分支所指向的同一個提交；
Git 也會建立屬於你自己的 `master` 本地分支，同樣地，它也指向同一個提交，以便讓你可以從這裡開始工作。

[NOTE]
.「origin」並不特別
====
就像分支名稱「master」在 Git 中並沒有特別的含意，「origin」同樣也並不特別；
「master」會被廣泛地使用的唯一理由只是在執行 `git init` 時使用了預設的「master」做為起始的分支；同樣地，「origin」也只是在執行 `git clone` 時所使用的預設遠端簡稱。
如果你執行 `git clone -o booyah`，預設的遠端追蹤分支將會是 `booyah/master`。(((origin)))
====

.克隆後，伺服器和本地端的版本庫
image::images/remote-branches-1.png[克隆後，伺服器和本地端的版本庫。]

如果你在本地分支 `master` 做了一些工作，與此同時，有人推送到 `git.ourcompany.com` 而更新了伺服器上的 `master` 分支，這會讓你的提交歷史朝著不同方向發展；
不過只要你不和伺服器連絡，你的 `origin/master` 指標並不會移動。

.本地和遠端的歷史分離開來
image::images/remote-branches-2.png[本地和遠端的歷史分離開來。]

執行 `git fetch origin` 可以同步遠端伺服器上的資料到本地，
該命令首先尋找 `origin` 是哪個伺服器（本例是 `git.ourcompany.com`），從上面獲取你尚未擁有的資料，更新你本地的資料庫，然後把 `origin/master` 指標同步到最新的位置。

.`git fetch` 會更新你的遠端參照
image::images/remote-branches-3.png[`git fetch` 會更新你的遠端參照。]

為了演示在擁有多個遠端伺服器的情況下，這些遠端專案的遠端分支看起來會長什麼樣，我們假設你還有另一個僅供你的敏捷開發小組使用的內部 Git 伺服器，
這個伺服器位於 `git.team1.ourcompany.com`，
你可以用我們在 <<_git_basics_chapter>> 中所提到的 `git remote add` 命令為目前的案案加入一個新的遠端版本庫，
並把它命名為 `teamone` 以做為那個完整的 URL 的簡稱。

.加入另一個遠端伺服器
image::images/remote-branches-4.png[加入另一個遠端伺服器。]

現在你可以用 `git fetch teamone` 來取得 `teamone` 伺服器上你還沒有的資料了，
由於那個伺服器上的內容是 `origin` 伺服器上的子集合，Git 並不會下載任何資料，但是會建立一個名為 `teamone/master` 的遠端追蹤分支，指向 `teamone` 伺服器的 `master` 分支所指向的同一個提交。

.遠端追蹤分支 `teamone/master`
image::images/remote-branches-5.png[遠端追蹤分支 `teamone/master`。]

[[_pushing_branches]]
==== 推送的用法

(((pushing)))
當你想跟世界分享某個分支，你需要把它推送到一個你擁有寫入權限的遠端版本庫；
你的本地分支並不會自動同步到遠端上——你必需明確地推送你想分享的分支；
透過這種方式，你可以將無意分享的分支保留下來做為私用分支，而只推送需要協同工作的主題分支。

如果你有個叫做 `serverfix` 的分支需要和其他人一起開發，
執行 `git push <遠端> <分支>`：(((git commands, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

這裡其實走了一點捷徑，
Git 會把 `serverfix` 分支名稱自動地擴展為 `refs/heads/serverfix:refs/heads/serverfix`，意思是：「使用本地端的 serverfix 分支推送，以更新遠端的 serverfix 分支」（譯註：冒號之前是本地端，冒號之後是遠端）；
我們將在 <<_git_internals>> 進一步介紹 `refs/heads/` 的細節，不過一般來說你可以先將它拋在腦後。
執行 `git push origin serverfix:serverfix` 也會做相同的事——它的意思是：「使用本地端的 serverfix 分支建立遠端的 serverfix 分支」；
你可以用這種格式把本地分支推送到遠端的異名分支，
假設你不想在遠端把它叫做 `serverfix`，可以用 `git push origin serverfix:awesomebranch` 將本地端的 `serverfix` 分支推送到遠端專案的 `awesomebranch` 分支。

[NOTE]
.不想每次都輸入密碼
====
如果你正在使用 HTTPS URL 推送資料，Git 伺服器為了核對身份會詢問你的帳號和密碼；
預設情況它會在終端提示你輸入相關資訊，這樣伺服器才能分辨你是否有推送權限。

如果你不想每次推送時都輸入它們，你可以設置「證書快取」；
最簡單的方式是執行 `git config --global credential.helper cache` 將它保留記憶體幾分鐘。

詳見 <<_credential_caching>> 以取得各種可使用的、詳細的證書快取方式。
====

當你的協作者下次從伺服器上獲取資料時，他們將得到一個新的遠端追蹤分支 `origin/serverfix` 指向伺服器上的 `serverfix` 所指向的同一個版本：

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

有一點很重要請注意：`fetch` 操作會產生新的遠端追蹤分支，但是並不會自動產生本地分支；
換句話說，在本例中，你不會有一個新的 `serverfix` 分支——你只會有一個無法更動的 `origin/serverfix` 指標。

執行 `git merge origin/serverfix` 可以把 `origin/serverfix` 的內容合併到目前分支；
如果想要一個你自己的 `serverfix` 分支用來開發，可以在遠端分支的基礎上分化出一個本地分支：

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

它會給你一個本地分支 `serverfix`，並且可以在 `origin/serverfix` 的基礎上繼續開發。

[[_tracking_branches]]
==== 追蹤分支

(((branches, tracking)))(((branches, upstream)))
從遠端追蹤分支身上檢出的本地分支會自動升級為「追蹤分支」（它所追蹤的分支則稱為「上游分支」），
追蹤分支是一種和某個遠端分支有直接聯繫的本地分支；
如果你切換到追蹤分支並執行 `git pull`，Git 會自動分辨要從哪一個伺服器獲取資料，然後自動辨別要合併哪一個分支進來（譯註：就是合併上游分支）。

在克隆一個版本庫時，Git 通常會自動建立一個名為 `master` 的分支用來追蹤 `origin/master`；
然而，如果你想要的話，你可以設定其它追蹤分支——改變追蹤其它遠端上的分支，或者不再追蹤遠端的 `master` 分支。
`git checkout -b [分支] [遠端]/[分支]` 是一個你剛剛才看過的簡單例子，
你還可以用一個相當常用的 `--track` 選項簡化這個操作：

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

事實上，由於太常使用它了，所以還有更簡短的用法；如果你想檢出的分支名稱符合：(a) 尚未存在、(b) 只在一個遠端中完全匹配分支名稱，Git 將會為你產生一個追蹤分支：

[source,console]
----
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

要使用不同於遠端分支名稱的本地分支，只需在第一個版本的命令中替換分支名稱：

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

現在你的本地分支 `sf` 將會自動從 `origin/serverfix` 拉取資料。

如果你已經有一個本地分支，並且想要它追蹤一個你剛下載的遠端追蹤分支，或者想要改變追蹤上游分支，在任何時候都可以使用 `git branch` 的 `-u` 或 `--set-upstream-to` 選項來明確地設定。

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.上游稱簡
====
當你設定了追蹤分支，你可以用 `@{upstream}` 或 `@{u}` 來表示它的上游分支；
假設你在 `master` 分支而它追蹤了 `origin/master`，如果你想要的話你可以用 `git merge @{u}` 來取代 `git merge origin/master`。(((+++@{u}+++)))(((+++@{upstream}+++)))
====

如果你想知道你設定了哪些追蹤本支，你可以使用 `git branch` 的 `-vv` 選項；
它以更詳盡的資訊列出本地分支，其中包括了它追蹤的分支為何，它們是超前、落後，或者二者都有！？

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

在這個例子中可以看到分支 `iss53` 正在追蹤 `origin/iss53`，並且它「超前」了二個提交，意思是本地端有二個提交還沒推送到伺服器；
也可以看到 `master` 正在追蹤 `origin/master`，並且已經是最新的；
再下一個可以看到分支 `serverfix` 追蹤的是 `teamone` 的 `server-fix-good` 分支，它超前三個提交，也落後一個提交；意思是伺服端有一個提交還沒有合併進來，同時該分支也有三個提交還沒推送到出去（譯注：其實就是本地端有三個新提交，遠端有一個新提交，二邊的歷史開始分離了）。
最後，可以看到 `testing` 分支沒有追蹤任何遠端分支。

必需要注意的是：這些數字是最後一次從每個伺服器獲取資料後所得出的結果，
也就是這個命令並不會連到伺服器去取得相關資料，它只是告訴你上次快取伺服器的狀態後的結果。
如果你想要完完全全地取得最新的「超前／落後」數字，你需要先將所有伺服器的資料獲取下來，再執這個命令。
你可以這樣做： `git fetch --all; git branch -vv`

==== 拉取的用法

(((pulling)))
`git fetch` 命令會獲取伺服器上你尚未擁有的所有資料，它並不會去改動你工作目錄的內容；
它只是簡單地取得資料，然後讓你自己去合併工作。
然而，有個命令叫做 `git pull`，在大部分情況下，它實質上等於執行 `git fetch` 後立即執行 `git merge`；
如果你像上一節中所展示的那樣設定追蹤分支——不管是明確地設定它，或者是透過 `clone` 或 `checkout` 命令自動幫你設定——`git pull` 將會查詢目前分支正在追蹤哪一個伺服器上的哪一個分支，然後從那個伺服器獲取資料並合併那個遠端分支的工作。

一般來說，最好明確地使用 `fetch` 和 `merge` 命令，因為神奇的 `git pull` 常常令人困惑。

[[_delete_branches]]
==== 刪除遠端分支

(((branches, deleting remote)))
如果你不再需要某個遠端分支了——例如你和你的同事已經完成了某個特性並把它合併到遠端的 `master` 分支（或合併到任何其它穩定分支裡）；
你可以使用 `git push` 的 `--delete` 選項刪除那個遠端分支；
例如想刪除伺服器上的 `serverfix` 分支，執行下面的命令：

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

基本上，這只是移除了伺服器上的分支指標而已；
Git 伺服器基本上會保留資料一段時間（直到執行垃圾回收），所以如果它是不小心被刪除的，還可以很容易地還原回去。
