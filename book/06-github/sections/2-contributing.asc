=== 參與一個專案

現在帳號設定好了，來看看一些關於如何對現有專案做出貢獻的有用小細節吧。

==== Fork 專案

(((forking)))
如果你想要參與一個你沒有 push 權限的專案，你可以 ``fork'' 一份。這代表說 GitHub 會複製一份這個專案的副本給你，並且你對這副本有全部的權限。這副本會存在於你的帳號下，你可以對它 push。

[NOTE]
===
歷史上來說，``fork''這件事情在城市開發的領域裡多少帶了點負面意味。因為有些人會透過這途徑將一個開源專案的發展帶往不同方向，甚至是創造出跟原本專案競爭的作品，進而導致貢獻者的分裂。
在 GitHub 上，``fork'' 就是把一份相同的專案放在你的帳號之下，讓你能夠公開對這專案做變更，做為一個以更開放的方式來參與專案。
====

透過這方式，專案就不用去煩惱需要把所有協作者加入使用者來讓他們擁有 push 的權限。
所有人可以 fork 專案，對 fork 出來的專案 push 變更，然後去發出我們等下會提到的 Pull Request，來把這些變更貢獻回原本的專案裡。
這會開立一個能夠作程式碼審閱的討論串，然後擁有者能和貢獻者討論這個變更，直到擁有者覺得可以合併進原始專案裡面。
This opens up a discussion thread with code review, and the owner and the contributor can then communicate about the change until the owner is happy with it, at which point the owner can merge it in.

去到專業頁面，點下右上角的 ``Fork'' 鍵，就可以 fork 專案。

.``Fork'' 鈕.
image::images/forkbutton.png[The ``Fork'' button.]

幾秒鐘之後，你就會被帶到你有寫入權限的新專案頁面。


[[_github_flow]]
==== The GitHub Flow

(((GitHub, Flow)))
GitHub 是基於一個以 Pull Request 為中心的特別合作流程而設計出來的。
這個流程，不論是你在一個緊密連結的團隊裡共同在單一倉儲上合作；或是一個由散布全球的陌生人們構成的合作網路或是公司，透過大量的 fork 專案來對專案做出貢獻，都能運作。
這一切都是基於我們在 <<_git_branching>> 這章所講過的 <<_topic_branch>> 的工作流程。

一般情況下就是照著下面的程序運作的：

1. 從 `master` 建立一個主題 branch。
2. 加入一些變更來改善這個專案。
3. 把這個分支 push 到你的 GitHub 專案。
4. 在 GitHub 上建立一個 Pull Request。
5. 討論，並在需要的時候加入新的變更。
6. 專案擁有者視情況決定要把這個 Pull Request 合併進原始專案，或是關閉他。

這基本上就是我們在 <<_integration_manager>> 這部分提過的整合式管理流程，不過我們是使用 GitHub 的網頁工具來做溝通或是變更審閱，而非電子郵件。

我們來看看下面的例子來了解如何使用這個流程來對 GitHub 上的專案做出變更吧。

===== 建立一個 Pull Request

Tony 在找能夠在他的 Arduino 可程式化微控制器上運作的程式碼。然後他在 GitHub 的這個專案 https://github.com/schacon/blink[] 找到了個很棒的程式碼。
Tony is looking for code to run on his Arduino programmable microcontroller and has found a great program file on GitHub at https://github.com/schacon/blink[].

.他想要做出貢獻的專案.
image::images/blink-01-start.png[The project we want to contribute to.]

唯一的小問題就是閃爍的頻率太高了，我們覺得放慢成 3 秒一次會比原本的 1 秒一次好。所以我們來改善這個程式並作為變更要求來提交回去吧。

首先，我們要先按下稍早提過的 'Fork' 鈕來取得這個專案的副本。我們在這邊使用的使用者名稱是 ``tonychacon''，所以這個專案的副本會放在 `https://github.com/tonychacon/blink`，而且我們能編輯這個副本。我們把它克隆一分到電腦上、建立主題分支、對程式碼作變更，最後 push 回 GitHub。

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> 把我們 fork 的專案克隆一分到本機
<2> 建立名稱有意義的主題分支
<3> 對程式碼作變更
<4> 確認這個變更一切 OK
<5> 把變更加入我們的主題分支
<6> 把我們的新分支 Push 回 GitHub 的 fork 上

如果我們回到我們在 GitHub 上的 fork ，我們可以看到 GitHub 發現我們推了新分支上來，並且顯示了一個大大的綠色按鈕讓我們可以檢視我們的變更，並能對原始專案開啟一個 Pull Request 。

你也可以去到 在 `https://github.com/<user>/<project>/branches` 上的 ``Branches'' 頁面去找出你的 branch 並從那邊開啟一個新的 Pull Request。

.Pull Request 按鈕.
image::images/blink-02-pr.png[Pull Request button]

(((GitHub, pull requests)))
如果我們按下綠色按鈕，我們會看到一個畫面，可以針對這次的變更來編寫標題和描述，讓專案擁有人願意對這變更考慮一下。
通常花點心力來寫出一個讓這個描述盡可能的有意義會是個不錯的主意，這樣原作者就能知道這個變更的好處進而讓他接受這個變更。
同時也會看到一個我們比主分支多做過的所有變動的清單(在這個案例裡只有一個)，和一個包含所有將要合併的差異總表。

.Pull Request 建立頁面
image::images/blink-03-pull-request-open.png[Pull Request creation]

當你按下畫面中的 'Create pull request' 按鈕時，你 fork 的來源專案的擁有者會收到一個通知，通知他有人建議一個變動並且會附上連往包含所有資訊的頁面連結。

[NOTE]
====
雖然在這種公開專案上，Pull Requests 通常都是在貢獻者已經準備好要加入的變更時才會發出；但是他常用於專案 _剛開始_ 時的一些內部專案。
基於 Pull Request 在建立 *之後* 仍然可以持續加入新的變更的特性，因此也常會在初期建立當作一個團隊合作的環境，而非在最後才使用。
====

===== 重複使用一個 Pull Request

現在呢，專案的擁有者可以閱覽所有建議的變更，然後決定要合併進來、拒絕變更或是對這留下評論。在這邊我們當作他覺得他喜歡這點子好了，但是他覺得燈暗掉的時間要比亮的時間長一點。

這個互動或許會透過電子郵件並依照在 <<_distributed_git>> 提到的工作流程運作；而在 GitHub 上，這是在線上運作的。專案擁有者可以在審閱差異總表時，點一下想要評論的那行內容並留下評論。

.對 Pull Request 的某行程式碼下評論
image::images/blink-04-pr-comment.png[PR line comment]

當維護者留下評論，建立這個 Pull Request 的人（以及所有關注這個倉儲的人）都會收到通知。我們等等會對這做自訂，不過如果有開啟電子郵件通知，Tony 會這樣的一封信：

[[_email_notification]]
.以電子郵件型式寄送的評論
image::images/blink-04-email.png[Email notification]

其他人也可以對 Pull Request 留下一般評論。 在 <<_pr_discussion>> 裏面我們可以看到專案擁有者對某行程式碼做評論，同時也在討論區塊留了一般評論。你可以看到程式碼評論也會被帶到這個互動之中。

[[_pr_discussion]]
.Pull Request 討論頁
image::images/blink-05-general-comment.png[PR discussion page]

現在貢獻者就可以知道他要做哪些處理才能讓擁有者接受這個變更。剛好這也是個能輕鬆達成的事。如果是透過電子郵件的話你需要把所有的變動重新執行一次然後重新上傳，但是在 GitHub 上你只要對主題分支再次做 commit 然後 push 上去即可。

如果貢獻者做了這樣的動作，專案擁有者會再次收到通知；當他們再次開啟這個頁面時就可以看到新發佈的變動。 事實上，當有加評論的那行程式碼有變動時，GitHub 會注意到並處理過期的差異表。

[[_pr_final]]
.結束 Pull Request
image::images/blink-06-final.png[PR final]

An interesting thing to notice is that if you click on the ``Files Changed'' tab on this Pull Request, you'll get the ``unified'' diff -- that is, the total aggregate difference that would be introduced to your main branch if this topic branch was merged in. In `git diff` terms, it basically automatically shows you `git diff master...<branch>` for the branch this Pull Request is based on. See <<_what_is_introduced>> for more about this type of diff.

The other thing you'll notice is that GitHub checks to see if the Pull Request merges cleanly and provides a button to do the merge for you on the server. This button only shows up if you have write access to the repository and a trivial merge is possible. If you click it GitHub will perform a ``non-fast-forward'' merge, meaning that even if the merge *could* be a fast-forward, it will still create a merge commit.

If you would prefer, you can simply pull the branch down and merge it locally. If you merge this branch into the `master` branch and push it to GitHub, the Pull Request will automatically be closed.

This is the basic workflow that most GitHub projects use. Topic branches are created, Pull Requests are opened on them, a discussion ensues, possibly more work is done on the branch and eventually the request is either closed or merged.

[NOTE]
.Not Only Forks
====
It's important to note that you can also open a Pull Request between two branches in the same repository. If you're working on a feature with someone and you both have write access to the project, you can push a topic branch to the repository and open a Pull Request on it to the `master` branch of that same project to initiate the code review and discussion process. No forking necessary.
====

==== Advanced Pull Requests

Now that we've covered the basics of contributing to a project on GitHub, let's cover a few interesting tips and tricks about Pull Requests so you can be more effective in using them.

===== Pull Requests as Patches

It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions. Most GitHub projects think about Pull Request branches as iterative conversations around a proposed change, culminating in a unified diff that is applied by merging.

This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions. This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort. When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.

For instance, if you go back and look again at <<_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made. Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.

===== Keeping up with Upstream

If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it. GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.

[[_pr_fail]]
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]

If you see something like <<_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.

You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.

Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.

If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.

For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch into your topic branch
<4> Fix the conflict that occurred
<5> Push back up to the same topic branch

Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.

[[_pr_merge_fix]]
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]

One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.

If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.

===== References

Your next question may be ``How do I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.

Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.

Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<_pr_references>>.

[[_pr_references]]
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]

When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.

[[_pr_references_render]]
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]

Notice that the full GitHub URL we put in there was shortened to just the information needed.

Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it. The link will look something like <<_pr_closed>>.

[[_pr_closed]]
.Cross references rendered in a Pull Request.
image::images/mentions-03-closed.png[PR closed]

In addition to issue numbers, you can also reference a specific commit by SHA-1. You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.

==== Markdown

Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.

See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.

[[_example_markdown]]
.An example of Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]

===== GitHub Flavored Markdown

The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.

====== Task Lists

The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.

You can create a task list like this:

[source]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_task_lists>>

[[_task_lists]]
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]

This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.

What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<_task_list_progress>>.

[[_task_list_progress]]
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]

These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.

====== Code Snippets

You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.

To add a snippet of code you have to ``fence'' it in backticks.

[source]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.

[[_md_code]]
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]

====== Quoting

If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.

The quotes look something like this:

[source]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

Once rendered, the comment will look like <<_md_quote>>.

[[_md_quote]]
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]

====== Emoji

Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.

[[_md_emoji_auto]]
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]

Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:

[source]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

When rendered, it would look something like <<_md_emoji>>.

[[_md_emoji]]
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]

Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.


[NOTE]
====
There are actually quite a number of web services that make use of emoji characters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====

====== Images

This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.

[[_md_drag]]
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]

If you look back at <<_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
