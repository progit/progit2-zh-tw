=== 參與一個專案

現在帳號設定好了，來看看一些關於如何對現有專案做出貢獻的有用小細節吧。

==== Fork 專案

(((forking)))
如果你想要參與一個你沒有 push 權限的專案，你可以 ``fork'' 一份。這代表說 GitHub 會複製一份這個專案的副本給你，並且你對這副本有全部的權限。這副本會存在於你的帳號下，你可以對它 push。

[NOTE]
===
歷史上來說，``fork'' 這件事情在城市開發的領域裡多少帶了點負面意味。因為有些人會透過這途徑將一個開源專案的發展帶往不同方向，甚至是創造出跟原本專案競爭的作品，進而導致貢獻者的分裂。
在 GitHub 上，``fork'' 就是把一份相同的專案放在你的帳號之下，讓你能夠公開對這專案做變更，做為一個以更開放的方式來參與專案。
====

透過這方式，專案就不用去煩惱需要把所有協作者加入使用者來讓他們擁有 push 的權限。
所有人可以 fork 專案，對 fork 出來的專案 push 變更，然後去發出我們等下會提到的 Pull Request，來把這些變更貢獻回原本的專案裡。
這會開立一個能夠作程式碼審閱的討論串，然後擁有者能和貢獻者討論這個變更，直到擁有者覺得可以合併進原始專案裡面。

去到專業頁面，點下右上角的 ``Fork'' 鍵，就可以 fork 專案。

.``Fork'' 鈕
image::images/forkbutton.png[``Fork'' 鈕]

幾秒鐘之後，你就會被帶到你有寫入權限的新專案頁面。


[[_github_flow]]
==== The GitHub Flow

(((GitHub, Flow)))
GitHub 是基於一個以 Pull Request 為中心的特別合作流程而設計出來的。
這個流程，不論是你在一個緊密連結的團隊裡共同在單一倉儲上合作；或是一個由散布全球的陌生人們構成的合作網路或是公司，透過大量的 fork 專案來對專案做出貢獻，都能運作。
這一切都是基於我們在 <<_git_branching>> 這章所講過的 <<_topic_branch>> 的工作流程。

一般情況下就是照著下面的程序運作的：

1. 從 `master` 建立一個主題 branch。
2. 加入一些變更來改善這個專案。
3. 把這個分支 push 到你的 GitHub 專案。
4. 在 GitHub 上建立一個 Pull Request。
5. 討論，並在需要的時候加入新的變更。
6. 專案擁有者視情況決定要把這個 Pull Request 合併進原始專案，或是關閉他。

這基本上就是我們在 <<_integration_manager>> 這部分提過的整合式管理流程，不過我們是使用 GitHub 的網頁工具來做溝通或是變更審閱，而非電子郵件。

我們來看看下面的例子來了解如何使用這個流程來對 GitHub 上的專案做出變更吧。

===== 建立一個 Pull Request

Tony 在找能夠在他的 Arduino 可程式化微控制器上運作的程式碼。然後他在 GitHub 的這個專案 https://github.com/schacon/blink[] 找到了個很棒的程式碼。

.他想要做出貢獻的專案
image::images/blink-01-start.png[他想要做出貢獻的專案]

唯一的小問題就是閃爍的頻率太高了，我們覺得放慢成 3 秒一次會比原本的 1 秒一次好。所以我們來改善這個程式並作為變更要求來提交回去吧。

首先，我們要先按下稍早提過的 'Fork' 鈕來取得這個專案的副本。我們在這邊使用的使用者名稱是 ``tonychacon''，所以這個專案的副本會放在 `https://github.com/tonychacon/blink`，而且我們能編輯這個副本。我們把它克隆一份到電腦上、建立主題分支、對程式碼作變更，最後 push 回 GitHub。

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> 把我們 fork 的專案克隆一份到本機
<2> 建立名稱有意義的主題分支
<3> 對程式碼作變更
<4> 確認這個變更一切 OK
<5> 把變更加入我們的主題分支
<6> 把我們的新分支 Push 回 GitHub 的 fork 上

如果我們回到我們在 GitHub 上的 fork ，我們可以看到 GitHub 發現我們推了新分支上來，並且顯示了一個大大的綠色按鈕讓我們可以檢視我們的變更，並能對原始專案開啟一個 Pull Request 。

你也可以去到 在 `https://github.com/<user>/<project>/branches` 上的 ``Branches'' 頁面去找出你的 branch 並從那邊開啟一個新的 Pull Request。

.Pull Request 按鈕
image::images/blink-02-pr.png[Pull Request 按鈕]

(((GitHub, pull requests)))
如果我們按下綠色按鈕，我們會看到一個畫面，可以針對這次的變更來編寫標題和描述，讓專案擁有人願意對這變更考慮一下。
通常，花費一些心思盡量寫出有用的說明是個不錯的主意，這樣原作者就能知道這個變更的好處進而讓他接受這個變更。
同時我們也會看到在主分支沒有的所有提交列表（在這個範例中只有一個提交），和一個彙整所有修改的差異資訊，以便讓其他人知道當原作者合併後會有哪些差異。

.Pull Request 建立頁面
image::images/blink-03-pull-request-open.png[建立 Pull Request]

當你按下畫面中的 'Create pull request' 按鈕時，你 fork 的來源專案的擁有者會收到一個通知，通知他有人建議一個變動並且會附上連往包含所有資訊的頁面連結。

[NOTE]
====
雖然在這種公開專案上，Pull Requests 通常都是在貢獻者已經準備好要加入的變更時才會發出；但是他常用於專案「剛開始」時的一些內部專案。
基於 Pull Request 在建立「之後」仍然可以持續加入新的變更的特性，因此也常會在初期建立當作一個團隊合作的環境，而非在最後才使用。
====

===== 重複使用一個 Pull Request

現在呢，專案的擁有者可以閱覽所有建議的變更，然後決定要合併進來、拒絕變更或是對這留下評論。在這邊我們當作他覺得他喜歡這點子好了，但是他覺得燈暗掉的時間要比亮的時間長一點。

這個互動或許會透過電子郵件並依照在 <<_distributed_git>> 提到的工作流程運作；而在 GitHub 上，這是在線上運作的。專案擁有者可以在審閱差異總表時，點一下想要評論的那行內容並留下評論。

.對 Pull Request 的某行程式碼下評論
image::images/blink-04-pr-comment.png[Pull Request 行評論]

當維護者留下評論，建立這個 Pull Request 的人（以及所有關注這個倉儲的人）都會收到通知。我們等等會對這做自訂，不過如果有開啟電子郵件通知，Tony 會這樣的一封信：

[[_email_notification]]
.以電子郵件型式寄送的評論
image::images/blink-04-email.png[郵件通知]

其他人也可以對 Pull Request 留下一般評論。 在 <<_pr_discussion>> 裏面我們可以看到專案擁有者對某行程式碼做評論，同時也在討論區塊留了一般評論。你可以看到程式碼評論也會被帶到這個互動之中。

[[_pr_discussion]]
.Pull Request 討論頁
image::images/blink-05-general-comment.png[PR discussion page]

現在貢獻者就可以知道他要做哪些處理才能讓擁有者接受這個變更。剛好這也是個能輕鬆達成的事。如果是透過電子郵件的話你需要把所有的變動重新執行一次然後重新上傳，但是在 GitHub 上你只要對主題分支再次做 commit 然後 push 上去即可。

如果貢獻者做了這樣的動作，專案擁有者會再次收到通知；當他們再次開啟這個頁面時就可以看到新發佈的變動。 事實上，當有加評論的那行程式碼有變動時，GitHub 會注意到並處理過期的差異表。

[[_pr_final]]
.結束 Pull Request
image::images/blink-06-final.png[結束 Pull Request]

有個有趣的東西就是如果你點開 Pull Request 的 ``Files Changed'' 分頁，你會得到一份 ``統整過的'' 差異表 —— 也就是所有當這個主題分支被合併進主要分支時會做的變動。以 ``git diff'' 的方式來講，就是自動顯示給你對 Pull Request 指定的主題分支做 ``git diff master...<branch>'' 的結果。看 <<_what_is_introduced>> 來了解更多關於這種差異表的事情。

另外一件你會注意到的就是 GitHub 會確認這個 Pull Request 是否能直接合併，並顯示一個能讓你直接在伺服器上做合併的按鈕。這個按鈕只有在你對這個倉儲有寫入權限，而且能簡易的合併時才會出現。當你按下這個按鈕時，GiHub 會做一個 ``非快速向前'' 的合併，意味著即使這個合併 *能* 以快速向前的方式處理，GitHub 還是會建立一個合併的 commit。

你可以基於你的偏好改用這樣的方式：pull 這個分支下來，然後在本機合併進去。如果你把這個分支合併進 `master` 分支並 push 上 GitHub，對應的 Pull Request 會自動關閉。

大部分的 GitHub 專案都使用著這樣的基本流程。建立主題分支，基於這分支建立 Pull Request，針對這個做討論，可能還會在這分支上做更多變更，最後這個要求就被關閉或合併了。

[NOTE]
.不只有 Forks
====
有件很重要的事就是你可以對同個倉儲的兩個分支做 Pull Request。如果你跟別人在一個雙方都有寫入權限的專案編寫新功能；你可以 push 一個主題分支到倉儲裡，然後以這個分支對同個專案裡的 `master` 建立一個 Pull Request，藉此來做程式碼審閱以及討論。這不需要 Fork。
====

==== Pull Request 的進階用法

現在我們已經講完關於對 GitHub 上的專案做貢獻的基本部份了。來看看一些讓你可以更有效率的使用 Pull Request 的小技巧吧。

===== 把 Pull Request 做成補丁

有點重要的事情是：很多專案並不會把這些 Pull Request 當成一系列可以乾淨確實的使用的完美補丁，就像許多基於郵件清單運作的專案對系列補丁貢獻的看法。大多數的 GitHub 專案是把 Pull Request 分支用來做多次對期望變更的交流溝通，並將結果集中在一個差異檔，並用其做合併。

這是個很重要的差異，因為通常變動會在程式碼完備之前就被提出，這點跟基於郵件清單的運作模式是天差地遠的。這讓維護者們可以更早做溝通，讓適合的解決方案可以在接受更多社群能量下誕生。當有人使用 Pull Request 提出程式碼，然後維護者或是社群建議了一個變更，雖然這補丁系列不會重來，但相對的會以一個新的 commit 的形式加入這個分支，並讓討論和背景可以齊頭並進。

舉例來說，你可以回到 <<__pr_final>> 這邊看看，你會注意到那個貢獻者並沒有把他的 commit 重組之後另外開個新的 Pull Request ，而是加入新的 commit 並 push 到原本的分支。如果之後你回去看看 Pull Request ，你可以看到之前我們為何做了這樣的變動的背景。當按下網站上的 ``Merge'' 鈕時，會建立一個參考那個 Pull Request 的合併 commit ，這樣當有需要時你可以很容易的就找到它並研究當初的交談內容。

===== Keeping up with Upstream

If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it. GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.

[[_pr_fail]]
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]

If you see something like <<_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.

You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.

Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.

If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.

For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch into your topic branch
<4> Fix the conflict that occurred
<5> Push back up to the same topic branch

Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.

[[_pr_merge_fix]]
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]

One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.

If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.

===== References

Your next question may be ``How do I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.

Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.

Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<_pr_references>>.

[[_pr_references]]
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]

When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.

[[_pr_references_render]]
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]

Notice that the full GitHub URL we put in there was shortened to just the information needed.

Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it. The link will look something like <<_pr_closed>>.

[[_pr_closed]]
.Cross references rendered in a Pull Request.
image::images/mentions-03-closed.png[PR closed]

In addition to issue numbers, you can also reference a specific commit by SHA-1. You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.

==== Markdown

Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.

See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.

[[_example_markdown]]
.An example of Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]

===== GitHub Flavored Markdown

The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.

====== Task Lists

The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.

You can create a task list like this:

[source]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_task_lists>>

[[_task_lists]]
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]

This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.

What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<_task_list_progress>>.

[[_task_list_progress]]
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]

These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.

====== Code Snippets

You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.

To add a snippet of code you have to ``fence'' it in backticks.

[source]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.

[[_md_code]]
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]

====== Quoting

If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.

The quotes look something like this:

[source]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

Once rendered, the comment will look like <<_md_quote>>.

[[_md_quote]]
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]

====== Emoji

Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.

[[_md_emoji_auto]]
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]

Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:

[source]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

When rendered, it would look something like <<_md_emoji>>.

[[_md_emoji]]
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]

Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.


[NOTE]
====
There are actually quite a number of web services that make use of emoji characters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====

====== Images

This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.

[[_md_drag]]
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]

If you look back at <<_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
