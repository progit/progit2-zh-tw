[[r_revision_selection]]
=== 選擇修訂版本

你能夠以 Git 使用多種方式來指定一個提交（commit）或某些範圍內的提交。
雖然不見得必要，但了解是有益處的。

==== 單一修訂版本

很顯然地，你可以利用每個提交的 SHA-1 雜湊值來指定它，不過還有更多方便、直覺的方法一樣可以辦到。
這個章節將會介紹各種取得單一提交的方法。

==== 簡短的 SHA-1

如果你輸入 SHA-1 的前幾個字元，Git 可以聰明地判斷這是哪一個提交，前提是提供的 SHA-1 片段至少 4 個字元，而且不會模稜兩可，也就是目前的版本庫中僅有一個提交是以此 SHA-1 片段作為開頭。

例如，假設你要查看一個你增加某些功能的提交，你應該會先執行 `git log` 指令並找到這個提交：

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
----

在這個例子中，假設要檢視 `1c002dd...` 這個提交，下列 `git show` 的指令都能達到相同的功能（假設簡短版本是明確、不模稜兩可的）：

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

Git 能夠為 SHA-1 值產生簡短且唯一的縮寫。
如果你在 `git log` 後面加上參數 `--abbrev-commit`，就會輸出簡短但唯一的值。預設使用 7 個字元，但為了確保 SHA-1 的縮寫不會模稜兩可，也許會使用更多的字元：

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
----

一般來說，一個專案只要用 8 到 10 個字元就足夠了。

舉例來說，Linux 核心專案有超過 450,000 個提交和 3.6 百萬個物件，是個相當大的專案，也只需要不超過 11 個字元 SHA-1 值就能達到不重複。

[NOTE]
.SHA-1 縮寫的說明
====

有許多人會擔心版本庫裡有兩個物件出現相同的 SHA-1 值，
然後呢？

如果你真的提交了一個物件雜湊出與先前物件相同的 SHA-1 值，Git 會發現先前物件已經在你的 Git 資料庫中，並假設它已經被寫入。
之後如果你試圖再次檢出（checkout）這個物件，你只會取得先前已經寫入的第一個物件。

然而，你應該知道這個情形發生的機率十分低。
SHA-1 值占用 20 位元組的大小，也就是 160 位元。
能夠確保每 2^80^ 個物件雜湊，會產生衝突的機率有 50% ，
（計算衝突機率的算式 `p = (n(n-1)/2) * (1/2^160)` ），
是 1.2 x 10^24^，
也就是 1 百萬 乘上 10 億 再乘上 10 億，
這是地球上沙子總數的 1,200 倍。

我們舉個例讓你了解 SHA-1 衝突什麼情況下會發生，
如果地球上 65 億人在進行開發，且每秒每個人都產生相當於整個 Linux 核心歷史（360 萬個 Git 物件）的程式碼，並提交到同一個超巨大的 Git 版本庫，必須持續大約 2 年的時間直到版本庫內有足夠的物件，才能滿足 50% 的機率產生一次的物件 SHA-1 衝突的條件。
這個機率比起開發團隊內每一個成員在同一個晚上遭遇不同的意外，還要來得低。
====

[[r_branch_references]]
==== 分支參照

引用一個特定提交最直接的方式是，有一個分支參照指向這個提交，
然後將 Git 指令中提交物件或 SHA-1 值的位置，替換成分支名稱。
例如，如果你想要知道分支最後一個提交物件，假設分支 `topic1` 下面的指令都能達到同樣的功能：

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

如果你想要只到分支指向哪一個特定 SHA-1 ，或想知道任何一個範例相關的 SHA-1 內容，你可以使用稱為 `rev-parse` 的 Git 底層工具，
你可以到 <<ch10-git-internals#ch10-git-internals>> 了解更多關於底層工具的訊息，基本上 `rev-parse` 只會在底層操作時用到，並非用於日常使用。
然而，當你有時想知道目前的狀況，會變得很有用，
就可以在你的分支執行 `rev-parse` 。

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[r_git_reflog]]
==== 參照日誌（RefLog）簡稱

Git 會在你工作時，默默地在背後保存一份 「參照日誌」，紀錄最近幾個月 HEAD 和分支參照的狀況，

你可以執行 `git reflog` 查看參照日誌：

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

不論如何，每次你的分支更新時，Git 會將資訊存到暫存歷史裡，
你可以利用這些資訊獲取之前的提交。
假如你想要查看版本庫 HEAD 前五次的紀錄，你可以用 `@{n}` 作為參照日誌輸出的參照：

[source,console]
----
$ git show HEAD@{5}
----

這個語法也可以用來查一個分支特定時間以前的參照紀錄，
例如，若要查看 `master` 昨天的紀錄，可以輸入

[source,console]
----
$ git show master@{yesterday}
----

就可以看到分支頂端昨天指向哪裡。
這個技巧只在資料還保存在參照日誌中才有用，所以無法查看幾個月之前的提交。

若想要參照日誌按照 `git log` 的輸出格式顯示，你可以執行 `git log -g`：

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

有件重要的事要注意，參照日誌只限於本地端，紀錄你在版本庫裡做的所有事情，
即使是相同的版本庫，這份參照資料也不會相同，當你初次克隆（clone）一個版本庫時，將會產生一個空白的參照日誌，代表你的版本庫還沒有任何動作發生。
如果你在至少兩個月前克隆版本庫，執行 `git show HEAD@{2.months.ago}` 才有用，若在五分鐘前才剛克隆，你將不會得到任何結果。

==== 祖代參照

祖代參照是另一個指向一個提交的主要方法。
如果你在參照後面加上 `^` 這個符號，Git 將解析為這個提交的親提交（the parent of that commit），
假設你的專案歷程如下：

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
----

你可以透過指定 `HEAD^` ，也就是「HEAD 的親提交」來查看之前的提交：

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

你也可以在 `^` 指定一個數字，舉例來說，`d921970^2` 代表「d921970的第二個親提交」。
這個語法只適用於有多個親代的合併提交，
第一個親代提交是合併時你所在分支，第二個親代提交則是你所合併的分支：

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

還有一種主要的祖代參照方式是使用 `~`。
`HEAD~` 和 `HEAD^` 都是指向第一個親代，
若在符號後面指定數字時就不太一樣，
`HEAD~2` 意思是「親代的親代」或是「祖代」，它將依據指定次數遍歷所有的第一親代，
例如，依照先前提到的專案歷程，`HEAD~3` 會是：

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

這也可以寫成 `HEAD^^^`，也就是第一親代的第一親代的第一親代：

[source,console]
----
$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

兩種語法也能合併使用，像是 `HEAD~3^2` 可以查看之前提交的第二親代（假設提交是一個合併提交），以此類推。

[[r_commit_ranges]]
==== 提交區間

你已經知道怎麼指向單一的提交，現在來看看如何指向一連串的提交。
對於管理你的分支特別好用，如果你有很多分支，你可以用來列出提交區間來解決像是「有哪些提交你尚未合併到主要的分支」的問題。

===== 雙點

雙點語法是區間指向最常用的語法，
這個語法常用來讓 Git 解析出哪些提交在這個分支有，但其他分支沒有。
例如，假設你有個提交歷程如 <<rdouble_dot>> 所示。

[[rdouble_dot]]
.Example history for range selection.
image::images/double-dot.png[Example history for range selection.]

你想要知道分支 experiment 有哪些提交尚未合併到分支 master，
你可以在 `git log` 後面加上參數 `master..experiment`，也就是「所有分支 experiment 有但是分支 master 沒有的提交」。
為了讓舉例可以更簡潔易懂，這邊使用圖片中英文字母代替實際日誌輸出，顯示的順序如下：

[source,console]
----
$ git log master..experiment
D
C
----

反之，你可以對調分支的名稱的位置，查看分支 `master` 參照到的提交但分支 `experiment` 沒有的。
`experiment..master` 可以查看哪些提交是分支 `master` 有但分支 `experiment` 沒有的：

[source,console]
----
$ git log experiment..master
F
E
----

保持最新進度和預覽那些提交需要被合併變得很方便，
這個語法另一個常見的情況是查看你即將推送到遠端的提交：

[source,console]
----
$ git log origin/master..HEAD
----

這個指令會顯示你分支上任何不在遠端 `origin` 的提交，
當你執行 `git push` 且目前的分支正在追蹤（track） `origin/master`，指令 `git log origin/master..HEAD` 所列出來的提交將會傳到伺服器。
當你在雙點語法一邊留空，Git 會預設為 HEAD。
例如，輸入 `git log origin/master..`，將會得到和先前的例子相同的結果，因為 Git 將留空的位置視為 HEAD。

===== 多點

雙點語法快速方便，但或許有時候你想要兩個以上的分支來指出你的修訂，像是查看哪些提交在多個分支上都有，但不在你現在的分支上，
Git 允許你在任何參照前加上字元 `^` 或是 `--not` 來指定你不想要提交被包含的分支。
因此下列三個指令有相同的功能：

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

這個語法最棒的就是你可以指定超過兩個參照，而雙點語法無法辦到。
例如，你想要查看分支 `refA` 或 `refB` 所參照的提交，但分支 `refC` 沒有的，你可以選擇下列其中一個指令執行：

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

這使得修訂查詢系統非常強大，對了解你的分支內有什麼很有幫助。

[[r_triple_dot]]
===== 三點

最後一個重要的區間選擇語法是三個點，這個語法可以列出只有一方參照、非雙方共同參照的提交，
請看一下之前 <<rdouble_dot>> 提交歷史的範例，
如果你想要查看 `master` 或者 `experiment` 這兩個分支僅有一方擁有的提交，你可以執行：

[source,console]
----
$ git log master...experiment
F
E
D
C
----

如同一般 `log` 輸出，這邊會顯示這四個提交的資訊，並按慣例照提交時間的順序顯示。

這個情況下，通常會在 `log` 指令加上參數 `--left-right`，顯示每一個提交是屬於哪一邊的分支，
讓輸出的資料更加清楚：

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

有了這些工具，你能更簡單地讓 Git 知道你想要檢查哪一個或哪一些提交。
